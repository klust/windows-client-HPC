{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Using Windows as a client and development platform for HPC","text":"<ul> <li>Introduction</li> <li>Protocols and technolgoeis<ul> <li>SSH</li> <li>Remote graphics</li> <li>Globus and GridFTP for file transfer</li> </ul> </li> <li>Creating a Linux-like environment on Windows<ul> <li>WSL and WSL2</li> <li>CygWin</li> </ul> </li> <li>Software<ul> <li>All-in-one</li> <li>Command line access via SSH</li> <li>File transfer via sftp</li> <li>File access via SSHFS</li> <li>X server</li> <li>VNC clients</li> <li>NX clients</li> </ul> </li> <li>Running a cluster software stack on Windows with EESSI<ul> <li>EESSI</li> <li>EasyBuild</li> <li>Spack</li> </ul> </li> <li>Issues<ul> <li>SSH key management</li> <li>Connecting to an X server in the Windows process space</li> <li>Securing an X server in the Windows process space</li> <li>Mapping users and groups between the Windows and WSL space</li> <li>Upgrading Linux in WSL</li> </ul> </li> <li>Appendix A: Management tips<ul> <li>openSUSE</li> <li>Fedora Remix</li> <li>Ubuntu</li> </ul> </li> <li>Appendix B: Links</li> </ul>"},{"location":"0_00_introduction/","title":"Introduction","text":"<p>Windows 10/11 rather than Linux as a client for a Linux-based HPC cluster? Yes, this is perfectly possible.  It can even be done using mostly free software (besides of course Windows itself). Windows 10, especially in the editions launched in October 2019 and later, and Windows 11 contain many of the tools that you might need, though they are often hidden as additional components in the Windows installation or as apps in the Microsoft store.</p> <p>In fact, it is even perfectly possible to create a Linux or Linux-like environment on your Windows machine, which will give you the best of both worlds in a single machine and an easy environment to test your code,  whether it is in an interpreted language such as Python or R, or a compiled language such as C, C++ or Fortran, on your PC on smaller problems before moving it to the HPC cluster. </p> <p>There are also tools that allow you to edit files on the cluster from your PC with an editor running on your PC. This is often preferable over the ancient text based editors on most clusters, or GUI programs that run very slowly over networks. </p> <p>Disclaimer: This is unofficial documentation and work-in-progress. It is the result of my work at the  CalcUA service of the University of Antwerp for the  Vlaams Supercomputer Centrum. However, as my main machine for work is macOS-based, this documentation is mostly written when I am working from home.</p>"},{"location":"B_Links/","title":"Appendix B: Links","text":"<ul> <li>GitHub \"Awesome WSK - Windows Subsystem for Linux\":     An overview of useful software for WSL: Terminals, X servers, WSL tools, ...</li> </ul>"},{"location":"1_ProtocolsTechnologies/","title":"Protocols and technologies","text":"<ul> <li>SSH</li> <li>Remote graphics</li> <li>Globus and GridFTP for file transfer</li> </ul>"},{"location":"1_ProtocolsTechnologies/1_01_SSH/","title":"Secure SHell (ssh)","text":"<p>Secure SHell is the basis for a lot of connections. It can be used</p> <ul> <li> <p>For telnet-style interactive shells</p> </li> <li> <p>For ftp-style data transfer</p> </li> <li> <p>For tunneling through a firewall and connecting to other network     services running in the cluster.</p> </li> </ul>"},{"location":"1_ProtocolsTechnologies/1_02_Remote_graphics/","title":"Remote graphics","text":"<p>Several technologies in the Linux-world support remote graphics and all have clients that support Windows.</p> <ul> <li> <p>X11 protocol:</p> </li> <li> <p>VNC</p> </li> <li> <p>NX-protocol</p> </li> </ul>"},{"location":"1_ProtocolsTechnologies/1_03_Globus/","title":"Globus and GridFTP for file transfer","text":"<p>Globus is the most popular implementation of the GridFTP protocol. This is a protocol that is optimized for large data transfers over high-latency connections that may even lack reliability.</p> <p>Globus data transfers happen between so-called endpoints. The endpoint software can be installed on big file servers -- and many supercomputer centers will offer a Globus endpoint to access your data there -- but there is also more feature-limited \"personal endpoint\" software to turn your desktop or laptop in a Globus endpoint. However, you don't need any specific software to initiate a data transfer between two endpoints. This is done via a web interface provided by the Globus service (globus.org). In this process, your actual data does not pass through the Globus.org servers nor through the computer on which you initiate the transfer but is transferred directly between the two end points. If connections get interrupted, data transfer will be restarted automatically when the connection is restored.</p> <p>So, among others, you can:</p> <ul> <li> <p>Transfer data between a supercomputer and a file server on your     department (provided both are Globus endpoints), initiating the     transfer from your laptop or even smartphone. Ones the data transfer     is initiated, there is no need to keep your laptop or smartphone     connected as it is not directly involved in the data transfer.</p> </li> <li> <p>Transfer data between two supercomputers on which you have an     account (which really is exactly the same case as the previous one).</p> </li> <li> <p>Transfer data to or from your laptop. In this case, you need to     install personal endpoint software on your laptop and register it     with the globus.org service. However, you can unplug your laptop     from the network while the data transfer is going on. The data     transfer will automatically resume when your laptop is on the     network again. This makes this a lot more user-friendly technology     to transfer large amounts of data than sftp, as sftp connections do     not automatically restart when interrupted.</p> </li> </ul>"},{"location":"2_LinuxOnWin/","title":"Creating a linux-like environment on Windows","text":"<ul> <li>WSL and WSL2</li> <li>CygWin</li> </ul>"},{"location":"2_LinuxOnWin/2_01_WSL/","title":"WSL and WSL 2","text":"<p>Windows Subsystem for Linux  is a product of Microsoft to emulate a Linux environment on top of Windows. There are two versions of the technology.</p>"},{"location":"2_LinuxOnWin/2_01_WSL/#wsl-1","title":"WSL 1","text":"<p>The oldest variant of the technology was originally known as WSL but is now more often denoted as WSL 1. It makes use of the kernel structure of the NT-based Windows versions (which is basically every version of Windows from Windows XP on), which can support subsystems that then can implement OS emulation. The original Windows NT kernel already had a POSIX subsystem as POSIX compatibility was a requirement to be able to sell Windows to certain USA government agencies.  Already in the '90s a third party company, Softway Systems, developed a more extensive UNIX emulation,  originally called OpenNT and later renamed to Interix. That technology required a re-compilation of UNIX software though. Microsoft acquired that technology and used it for a while in some Windows versions without much further development. However, it is rather  likely that WSL 1 found its roots in that technology, though most sources claim that it  started with an effort to try to run some Android applications on a version of Windows 10, a technology that was never released in its original form.</p> <p>WSL 1 differs from OpenNT/Interix in that it offers Linux compatibility and runs native Linux  binaries. It launched in 2016 with Windows 10.</p> <p>It was possible to install several versions of Linux on top of the subsystem. Many but not all user-level features of those Linux distributions could then be supported, but the kernel used in those distributions was replaced by the WSL subsystem which was not a real Linux kernel.</p>"},{"location":"2_LinuxOnWin/2_01_WSL/#wsl-2","title":"WSL 2","text":"<p>WSL 2 takes a completely different approach. It actually runs a real Linux kernel with just a few modifications in a virtual machine. It also can run several Linux distributions which effectively run in containers but share the single kernel. Since it is using a full Linux kernel, compatibility is much better than in WSL 1 though there are also some disadvantages. In particular, as it runs a  separate kernel, file access to Windows files is much slower than in WSL 1, but it has its own virtual file systems (per distribution) that are much faster than anything WSL 1 could offer.</p> <p>The WSL 2 subsystem has now also been extended with support for Wayland graphics (and X11 on top of Wayland). This technology was first only available in Windows 11 but has since been ported to Windows 10 also. It works through the remote display protocol, but it is completely transparent to users. On some GPUs, GPU compute is now also supported.</p> <p>In recent versions of Windows 10 and in Windows 11, WSL 2 can now be completely maintained from the Microsoft Store and updates happen completely independently from the regular Windows updates. </p>"},{"location":"2_LinuxOnWin/2_01_WSL/#linux-distributions","title":"Linux distributions","text":"<p>Many Linux distributions are available in the Microsoft store. The author of this text has experimented with three of them:</p> <ul> <li> <p>Fedora Remix for WSL     is a commercial product, though very cheap. It is produced by      Whitewater Foundry whose main product is the more expensive     Pengwin Enterprise distribution based on Red Hat that is oriented towards enterprise use.</p> <p>It is a nice distribution if you need something that is easy to install, not expensive, and has enough resemblance with clusters running Red Hat derived Linux distributions.</p> <p>It should be noted that AlmaLinux is also available in the Microsoft Store, but the author has no experience with that distribution. At the time of writing of these paragraphs, Rocky Linux, which seems to be the more popular CentOS replacement in HPC, was not available in the store.</p> </li> <li> <p>There are various SUSE Linux distributions available in the store, with different upgrade policies.     The author of these notes is using the openSUSE Leap distributions      (e.g., openSUSE Leap 15.4)     as the full Enterprise version     has some licensing issues, while the Leap distributions are still more stable than the rolling     Tumbleweed distribution.</p> <p>This is a good distribution if you want an environment that is close to the SUSE Linux based clusters, e.g., most Cray EX systems (including the European pre-exascale cluster LUMI).</p> </li> <li> <p>There are also various packages for Ubuntu developed by Canonical itself, with different upgrade     policies: one that follows the latest LTS release     and packages for individual LTS releases that are still maintained.     Originally only the LTS versions were offered for WSL but there is now also a version that offers a daily     preview of new features as they are developed.</p> </li> </ul>"},{"location":"2_LinuxOnWin/2_01_WSL/#integration-with-windows","title":"Integration with Windows","text":"<p>The Windows file systems are mounted in both versions of WSL. As WSL 1 uses more of an emulation approach, access to the Windows file systems can be done directly through the Windows kernel and is very fast.  On WSL 2 access to the Windows file systems is a lot slower and more like accessing a network file system as the Linux kernel has to pass the file access requests to the Windows side. WSL 2 offers virtual file systems in each distribution though that are very fast, and some versions of Windows can now directly  access files in those Linux distributions through explorer.</p> <p>It is also possible to access the Windows ssh agent though this is not as easy as it sounds. The approach is different in WSL 1 and WSL 2. Pointers to the exact procedure are given in the \"Issues - Using the Windows SSH Agent\" section. It may require updating the Windows SSH agent to a more recent version which strangely enough is currently not done through Windows Update or the Microsoft Store.</p>"},{"location":"2_LinuxOnWin/2_02_CygWin/","title":"CygWin","text":"<p>CygWin uses a completely different approach  to offer a level of Linux compatibility on Windows. It is basically a library that emulates offers a large subset of the POSIX APIs,  and much Linux software can be rebuild against this library. The resulting binaries are regular Windows binaries and not Linux binaries, which also implies that the Windows shared library approach is used rather than the Linux one.</p> <p>CygWin also comes with a large range of recompiled GNU and other Open Source tools.</p> <p>Since the binaries are regular Windows binaries, they can be started directly from any Windows shell (cmd.exe or PowerShell) and can be mixed with regular Windows executables easily.</p> <p>As CygWin programs are really Windows programs, they also see the same file systems as any other Windows program, though the CygWin translation layer will convert the paths into a more UNIX-like one, e.g., using the forward slash instead of the backslash and a different way of showing drive letters.</p> <p>The downside is that even source-level compatibility with Linux is certainly not as good as in WSL 1 or 2, and that certain Linux functionality which is not well supported by the  Windows kernel may come with a performance hit. Also, it cannot run native Linux  x86 binaries, neither 32-bit nor 64-bit ones.</p> <p>CygWin is also used internally by some of the software packages that we will mention in the Software chapter.</p> <p>There are other commercial products that use a similar approach,  e.g., the PTC MKS Toolkit.</p>"},{"location":"3_Software/","title":"Software","text":"<ul> <li>All-in-one</li> <li>Command line access via SSH</li> <li>File transfer via sftp</li> <li>File access via SSHFS</li> <li>X server</li> <li>VNC clients</li> <li>NX clients</li> </ul>"},{"location":"3_Software/3_01_allInOne/","title":"All-in-one","text":"<p>These are packages that provide terminal emulator functionality with support for ssh, support for file transfer over sftp, and an X server or other ways to run remote graphics.</p> <ul> <li> <p>MobaXTerm is maybe the most     popular package of this kind at the moment. It has a free version     with some restrictions on the number of connections (and a big     restriction in the license on support you can get from even just     your local system managers) and a commercial version based on a     subscription model. The package is so large and rich in     functionality that it becomes confusing. E.g., ssh is support both     via a built-in PuTTY (see below) and OpenSSH in the built-in CygWin     Linux emulation layer (which also offers a built-in bash shell), but     both use different key formats. However, it is very rich in     supported protocols. E.g., it also supports remote display     connections via VNC or RDP. Recent versions can also be used as a     terminal emulator to run WSL (Windows Subsystem for Linux) sessions.</p> </li> <li> <p>WinSSHTerm: This package is far     less complete as MobaXTerm and requires external packages to work.     It essentially combines the PuTTY/KiTTY ssh/terminal emulator,     WinSCP file transfer tool and VcXsrv X server.</p> </li> <li> <p>XMANAGER POWER SUITE and its subpackages     XSHELL for ssh and      XFTP for sftp and     XMANAGER for X.     It is not clear how integrated the suite is or if these should more be considered     as separate applications with bundle pricing. It is also a rather pricey package.</p> </li> </ul>"},{"location":"3_Software/3_02_CLI_SSH/","title":"Command line access via ssh","text":"<p>There are two ways to gain command line access to supercomputers through ssh:</p> <ul> <li> <p>Use terminal software with built-in ssh support</p> </li> <li> <p>Use regular terminal software that gives you a shell on Windows     (PowerShell, CygWin shell or a Windows Subsystem for Linux shell,     see also the section on creating a linux-like environment on     Windows) with a linux-style SSH client. Recent versions of Windows     bundle a native Windows implementation of the OpenSSH client that     can be run from PowerShell or any other shell that supports running     native Windows applications.</p> </li> </ul>"},{"location":"3_Software/3_02_CLI_SSH/#terminal-emulation-with-built-in-ssh-support","title":"Terminal emulation with built-in SSH support","text":"<ul> <li> <p>PuTTY has     long been the most popular terminal emulation package of this type.     The package is showing its age though and isn't really developed     anymore except for security updates. It also comes with some tools     for file transfer over sftp, but there is much better software for     that purpose. The package is free though.\\     PuTTY has seen several forks into packages that extend PuTTY in one     way or another. The best known one is probably     KiTTY, with many tiny improvements,     including the option to follow hyperlinks from the terminal.</p> </li> <li> <p>Bitvise SSH client is another     SSH client that has some popularity. It also includes support for     sftp.</p> </li> <li> <p>However, this list and the next one on terminal emulators are far     from complete. There are several other commercial and free options.</p> </li> </ul>"},{"location":"3_Software/3_02_CLI_SSH/#terminal-emulation-without-ssh-support","title":"Terminal emulation without SSH support","text":"<p>Windows supports several environments with OpenSSH clients: its own PowerShell that can use a Windows native OpenSSH implementation included in recent versions of Windows 10, CygWin, and Linux-distributions running in WSL 1 or WSL 2 (Windows Subsystem for Linux).</p> <p>To work comfortable, you'll still need a proper terminal emulation program as the ancient console window provided by Windows really isn't full-featured and doesn't benefit from features introduced in Windows 10 1809 (the ConPTY API).</p> <p>Some terminal emulators for Windows are:</p> <ul> <li> <p>Windows Terminal: This is Microsoft's own terminal program and is     100% free. It can be found in the Windows Store, and is in fact the     standard terminal for PowerShell on Windows 11. Initial versions     were tricky to customize, requiring editing a json file, but from     April 2020 on the program should also have a GUI for changing most     settings. It makes full use of the improved support in Windows     itself for UNIX-style terminals from May 2019 on. While it was     initially very rough around the edges, with those improvements it is     probably the terminal emulator to go for to have access to any shell     on your Windows system and make ssh connections from there. In fact,     using the built-in OpenSSH client from Windows it is even possible     to open sessions directly on your favourite cluster by using ssh as     the command to start a session.</p> </li> <li> <p>ConEmu: A long-time popular terminal,     though at this writing (early 2021) it doesn't seem as easy to use     with WSL as the Windows Terminal (which will detect your WSL     distributions automatically).</p> </li> </ul>"},{"location":"3_Software/3_03_SFTP/","title":"File transfer clients for sftp","text":"<ul> <li> <p>FileZilla</p> </li> <li> <p>WinSCP</p> </li> </ul>"},{"location":"3_Software/3_04_SSHFS/","title":"File access via SSHFS","text":"<p>SSHFS is a way to mount a remote file system over ssh. Under the hood it talks to  the ssh/sftp daemon on the server and sends commands to download or upload files when needed.</p> <p>It is not a true network file system so you have to be careful not to change files on both sides of the connection simultaneously. It does not offer any protection against this, e.g., full or partial file locking. Modifying files directly on  the server and on a mounted volume simultaneously will lead to unpredictable results.</p> <p>On Linux, where it was first introduced, sshfs is a userspace file system. So one needs tp first install a piece of software called FUSE to support user space file systems, and then the software that provides sshfs.  Implementations on other operating systems often follow a similar approach.</p>"},{"location":"3_Software/3_04_SSHFS/#in-windows-and-therefore-cygwin","title":"In Windows (and therefore CygWin)","text":""},{"location":"3_Software/3_04_SSHFS/#sshfs-win","title":"SSHFS-Win","text":"<p>SSHFS-Win follows the same approach as the Linux implementation.</p> <p>It first requires the installation of WinFsp or Windows File System Proxy, which has the same role as FUSE on Linux. It supports all recent Windows versions and supports several APIs for implementing user space file systems or port those from Linux.</p> <p>After installing WinSfp, SSHFS-Win can be installed. Downloads are also available from the WinFsp download section or you can download from the  sshfs-win GitHub.</p> <p>There are also GUI front ends available to help with creating the connections and drive  mappings. One is sshfs-win-manager which is  a small project on GitHub. The other one is SiriKali which supports multiple operating systems and several user space file systems.</p> <p>TODO: Check compatibility with keys.</p> Links <ul> <li>WinFsp web site</li> <li>WinFsp on GitHub</li> <li>sshfs-win on GitHub</li> </ul>"},{"location":"3_Software/3_04_SSHFS/#dokan","title":"Dokan","text":"<p>Dokan (GitHub: dokan-dev) is a similar project to SSHFS-Win that offers a FUSE wrapper and several userspace file systems running on top of it. Installation is again done in two phases. At the time of writing, the dokan-sshfs component is without maintainer and the installation information is not nearly as good as for SSHFS-Win. Dokan used to be a popular implementation, but as it died it has been forked into Dokany and now seems to be dying again.</p> <p>First the Dokany wrapper is installed following the installation instructions.</p> <p>Next dokan-sshfs can be installed. At the time of writing there don't seem to be pre-built packages available.</p>"},{"location":"3_Software/3_04_SSHFS/#commercial-implementations","title":"Commercial implementations","text":"<p>This list by no means aims to be complete.</p> <ul> <li> <p>Mountain Duck is a package from the developers of     CyberDuck that supports not only the sftp protocol (on which sshfs implementations     are based) but also several cloud storage technologies, including S3. Contrary to     CyberDuck it also allows to mount volumes and claims to use smart synchronization     that also enables offline work. It supports both Windows and macOS.</p> </li> <li> <p>NetDrive is a commercial package for Windows and macOS that does not     only support SSHFS but can also mount several other types of cloud storage as if it is a local file     system, including, e.g., S3. There is a personal version which is still relatively cheap, but the     team version which is needed to offer full privacy also on multi-user PCs is rather expensive to     academic standards.</p> </li> <li> <p>ExpanDrive is a similar product that also supports several cloud storage     solutions and supports not only Windows and macOS but even some Linux versions.</p> </li> <li> <p>/n software SFTP Drive also supports Windows, macOS and Linux.</p> </li> <li> <p>CloudMounter is another package enabling mounting from an     sftp server, and it too supports some other cloud storage technologies. It also exists in a version for macOS.</p> </li> </ul>"},{"location":"3_Software/3_04_SSHFS/#in-wsl","title":"In WSL","text":"<p>Note: We only tested with WSL 2.</p> <p>As WSL will map all Windows drives into the Linux domain, one approach is to use a Windows client as discussed in the previous section that maps an sshfs volume onto a drive letter.</p> <p>However, in WSL 2 it is also possible to install FUSE  to use userspace file systems and then install and run the regular Linux sshfs client.</p> <p>Note however that at the time of writing of this text (June 2023) the sshfs project is without maintainer, though there are some forks in which further development seems to be happening. If no new maintainer is found, it is rather likely that sshfs will be abandoned by Linux distributions as security bugs are no longer fixed.</p> <p>openSUSE Leap 15.4</p> <p>E.g., in the openSUSE LEAP 15.4 distribution, installing fuse and sshfs was as simple as</p> <pre><code>sudo zypper install sshfs\n</code></pre> <p>Once installed, a mount point should be created, e.g.,</p> <pre><code>mkdir -p /home/XXX/test_mount\n</code></pre> <p>and the remote volume can be linked, e.g.,</p> <pre><code>sshfs myuserid@myserver:/home/myuserid /home/XXX/test_mount -o follow_symlinks\n</code></pre>"},{"location":"3_Software/3_05_Xserver/","title":"X servers","text":"<p>Relevance</p> <p>This section is only relevant if you want to use an X server outside of the WSL environment, e.g., on a system where you only use CygWin as a Unix/Linux emulation layer and want to avoid the use of WSL. </p> <p>Since late November 2022 the Microsoft store version of WSL is available. This is a version of WSL2 that contains built-in support for WSL (dubbed WSLg). Windows 11 will render the image in the Linux server and push the image to the Windows screen via the Remote Display Protocol, but also include features to support OpenGL acceleration on the graphics card if a compatible Windows display driver is used. </p> <p>Also check the WSLg documentation on GitHub!</p> <p>In the past, there were several commercial X servers that offered much better performance than the freely available ones. These however have lost popularity, especially when the server running the X applications is not on the same very fast network, as the limited network bandwidth and higher latency of longer network connections obliterate any speed advantage over the free alternatives (though some might still offer more functionality).</p> <p>There are several X servers that are all derived from the X.org code base. Packaging those to run on Windows does require some effort from the developers of these packages, so some of the options below request a minor fee or donation to compensate for that effort.</p> <ul> <li> <p>Cygwin/X. Cygwin is a technology that     offers a lot of Linux-functionality on top of Windows. This     technology is discussed elsewhere. It also comes with an X server     derived from the X.org code base. However, as one also needs to     install the Cygwin system before being able to install the X server,     it does require some more effort from the user than the other     options given below. It is however entirely free.</p> </li> <li> <p>MobaTek MobaXterm: This product     was already discussed before. It's X-server is also based on the     X.org sources and in fact relies on the built-in Cygwin. However,     due to the integration in MobaXterm the interface is a bit more     polished. The MobaXterm does support the GLX extension, but it is     not clear if it is hardware accelerated or just a software OpenGL     emulation. Recent versions integrate nicely with WSL also (tested     with WSL2) and set the DISPLAY environment variable correctly so     that you can start X programs in your WSL sessions started from     MobaXterm. TODO: TEST ON A CLEAN MACHINE AS IT MAY PICK UP A     VARIABLE SET BY GWSL.</p> </li> <li> <p>GWSL: This free X server installs     from the Microsoft Store which makes it extremely easy to install     and gives you automatic updates. It is based on VcXsrv, the next one     in this list, but installs from the Windows store. It has a feature     to ensure that each WSL session starts with the display variable set     properly and a simple tool to create shortcuts to WSL graphical apps     to start them at the click of a button. GWSL does support the GLX     1.4 extension, but it is not clear if it is hardware accelerated or     just a software OpenGL emulation. Like all X servers further down in     the list, it is basically the work of a single person so there is no     guarantee that the work will continue and limited support.</p> <p>A big disadvantage of this X server is that it runs with access control disabled, allowing all computers on the network to access the X server unless the firewall on your machine stops the applications from doing so. But tuning the firewall to only let traffic from the WSL virtual machine pass is no easy feat, also because the feature that sets the DISPLAY variable doesn't use the internal virtual connection. It may be a good enough X server to use at home but it should not be used in public spaces or on, e.g., a university network.</p> </li> <li> <p>VcXsrv: This X server     runs independently from the Cygwin libraries. It relies on an older     version of the Microsoft compilers and some included libraries that     make Cygwin unnecessary. It is installed through a regular Windows     installer.</p> </li> <li> <p>Xming X Server: This     is another server that can run independently from Cygwin. While     VcXsrv uses the Microsoft compilers, the author of Xming relies on a     port of the GNU compiler collection (though of course you don't need     to have those compilers installed). It consists of two components:     the actual X server and a package with additional fonts. The server     is donationware (a minimum of 10 GBP will give you access to new     versions for a year), though an older version is available entirely     free. The donationware version does support the GLX extension. For     the free versions, there is a download with (the -mesa version) and     without GLX, but the GLX support is very outdated (GLX 1.2) given     that the free version is essentially the 2007 version of Xming. It     is installed through a regular Windows installer. Xming works nicely     with WSL1 as you can simply set the DISPLAY variable to localhost     but is a bit more tricky to use with WSL2, which runs in a virtual     machine and hence doesn't share localhost with Windows. You'll have     to start Xming with access control disabled (using the -ac command     line option) and set the DISPLAY environment variable in your WSL2     session with </p> <pre><code>export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print \\$2; exit;}'):0 \n</code></pre> <p>which is a trick that works with the other X servers also.</p> </li> <li> <p>X410: This is a port of the X.org X-server     solely for Windows 10 and packaged as a Windows Store app, making it     extremely easy to install and uninstall. It has a free time-limited     test version but afterwards it costs around 10 or 15 EURO (well, the     store claims it costs 49.99 EURO, but I've always seen the reduced     price of 14.99 EURO and at one point even 9.99 EURO). It is also     fully independent of the Cygwin libraries, which may make it an     excellent partner to use with Windows Terminal which is also a     Microsoft Store app.</p> </li> </ul> <p>Other free or nearly free X-servers:</p> <ul> <li>MicroImages     MI/X:     Previously a commercial offering offered as part of their GIS     software, but now made freely available. However, as this is based     on a very old version of X we advise against its use. It is likely     incompatible with many recent X packages.</li> </ul> <p>In case you really want to go for a commercial offering, these are some of the options:</p> <ul> <li> <p>Micro-Focus Reflection Desktop for     X     and Reflection Desktop Pro</p> </li> <li> <p>OpenText     Exceed     and Exceed     3D     (formerly Hummingbird Exceed):</p> </li> <li> <p>StarNet X-Win32</p> </li> <li> <p>PTC     X/Server.     This vendor also makes a Linux interoperability software layer     (similar to Cygwin) for Windows.</p> </li> </ul> <p>Many of the commercial offerings include the GLX extension for OpenGL software (or offer it for an additional fee) which is a feature not offered by all free servers, but it is not clear if their implementation is better than in the free servers that support the extension (e.g., by offering full hardware acceleration).</p> <p>Note that we have no recent experience with any of these commercial products.</p>"},{"location":"3_Software/3_06_VNC/","title":"VNC","text":""},{"location":"3_Software/3_07_NX/","title":"NX","text":""},{"location":"4_Cluster_Stack/","title":"Running a cluster software stack on Windows","text":"<p>Codes that only use standard C/C++ or Fortran will likely compile directly on Windows. the most popular commercial compiler on  Windows for C and C++ does however offer very little support for, e.g., OpenMP, an often used technology for shared memory computing. The Intel compilers may offer a solution here.</p> <p>One step up is using CygWin. You can then use the GNU compilers and a large fraction of the POSIX system calls will also be  supported. This will already support a larger range of applications.</p> <p>However, as WSL 2 is free this is the better technology to create a cluster-like environment on Linux. As this technology even enables running practically any Linux binary, many options are available to install scientific software. However, as the cores are shared with Windows, just don't expect that it will be a very noise-free  platform to also benchmark software, and some software may suffer.</p> <p>System managers on HPC clusters often prefer to install software  from sources to extract all performance out of a specific CPU, rather than using binaries compiled for a generic processor. Systems as Conda are less suited for that (though conda does offer some  critical libraries with multiple code paths for different CPUs). We will describe three options.</p> <ul> <li> <p>EESSI is an effort to build a software stack that is served via     a web based file system. It provides binaries for several      platforms. Though the most optimal binary for your PC may     not be there (as in particular Intel disables features in      cores of the PC variants of processors compared to the ones      they sell for HPC systems), it will often be able to offer a     binary that is close to optimal.</p> </li> <li> <p>EasyBuild is a software framework for installations of scientific     software and is also used in the EESSI project. It can help you to     do optimised installs from source for a lot of software.</p> </li> <li> <p>Spack is another such framework with a very different filosophy     but it also installs most software from sources and is probably the     most used of such frameworks.</p> </li> </ul> <p>Content:</p> <ul> <li> <p>EESSI</p> </li> <li> <p>EasyBuild</p> </li> <li> <p>Spack</p> </li> </ul>"},{"location":"4_Cluster_Stack/4_01_EESSI/","title":"Running a cluster software stack on Windows with EESSI","text":"<p>The goal of the EESSI project is to  make a full software stack available with binaries optimised for  several popular architectures via a read-only web based file system. So software is served on demand and does not require installing the complete stack on your PC.</p> <p>To this end it uses the so-called CernVM-FS file system. This requires the installation of some additional software in WSL 2 that  does not come from the standard software libaries.  WSL 2 also for a long time did not support the mechanisms that are needed to start the file system daemons automatically so a manual  intervention may be needed each time you restart WSL 2. </p> <p>At the time of writing of the last revision (December 2023), EESI is still very much in a prototype phase. However, it got some funding through the EuroHPC Centre of Excellence MultiXScale for further development so the speed may pick up a little. The EESSI documentation was outdated and did not yet cover the new setup that requires far fewer steps to get CernVM-FS working, so the instructions below are the result of some experimenting als.</p> <p>Getting it to work (without using a container, which would also require installing additional software in most if not all WSL Linux distributions) does require an initial effort.</p>"},{"location":"4_Cluster_Stack/4_01_EESSI/#example-setup-on-opensuse-in-wsl2","title":"Example: Setup on OpenSUSE in WSL2","text":"<p>Last update: 4 May 2024</p> <p>The \"Getting Started\" section of the CernVM-FS manual unfortunately does not contain instructions for SUSE Linux. There are relevant files though in the CVMFS repository @ CERN. In particular, look for the files in the newest <code>cvmfs-*</code> subdirectory and the <code>cvmfs-config</code> subdirectory.</p> <p>This setup is for openSUSE 15 (tested with 15.5) on WSL2 with systemd enabled so that the automounter can be used and so that it is no longer needed to call <code>cvmfs_config wsl2_start</code> every time the openSUSE distribution in WSL is restarted.</p> <ul> <li> <p>Ensure you have a openSUSE WSL2 setup with systemd running. We'll enable     autofs after installing EESSI (as it is installed as a dependency of      EESSI if it has not yet been installed for other reasons).</p> <ul> <li> <p>Ensure that the <code>wsl_systemd</code> pattern is installed to fully enable systemd:</p> <pre><code>sudo zypper install -n -t pattern wsl_systemd\n</code></pre> <p>There are other useful patterns also and they do not always play nice with updating <code>/etc/wsl.conf</code>...</p> </li> <li> <p>Ensure that <code>/etc/wsl.conf</code> exists and that the <code>[boot]</code> section contains the      line <code>systemd=true</code>. The minimal such file would be</p> <pre><code>[boot]\nsystemd=true\n</code></pre> </li> <li> <p>Right now it is time to restart the openSUSE WSL2 distribution, e.g.,      from a normal bash command line:</p> <pre><code>wsl.exe --terminate $WSL_DISTRO_NAME\n</code></pre> <p>or from powershell (terminating all WSL2 distros)</p> <pre><code>wsl --shutdown\n</code></pre> </li> </ul> </li> <li> <p>Similarly to what is done on Fedora in the official installation instructions,      install directly from this repository.</p> <p>First check the version in a browser by checkint the <code>cvmfs-*</code> subdirectories at ecsft.cern.ch/dist/cvmfs.</p> <p>Let's set the version in an environment variable:</p> <pre><code>version='2.11.3`\n</code></pre> <p>So we can now install the necessary packages with:</p> <pre><code>sudo zypper --no-gpg-checks install \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-config/cvmfs-config-default-2.1-1.noarch.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$version/cvmfs-$version-1.sle15.x86_64.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$version/cvmfs-libs-$version-1.sle15.x86_64.rpm\n</code></pre> <p>(You'll have to check the version of <code>cvmfs-config-default</code> also, there is a <code>-latest</code> version but when checking this was actually a rather old file.)</p> </li> <li> <p>Note that it is no longer needed to install the EESSI configuration file for CernVM-FS     (<code>cvmfs-config-eessi-latest.noarch.rpm</code>) as the new EESSI repository is included in     the configurations of CVMFS.</p> </li> <li> <p>Create (you'll have to run in a bash shell as root or run the editor using <code>sudo</code>) the file     <code>/etc/cvmfs/default.local</code>. If you're experimenting on a workstation with no nearby cache      server for CernVM-FS, then the following would be appropriate:</p> <pre><code>CVMFS_CLIENT_PROFILE=\"single\"\nCVMFS_HTTP_PROXY=\"DIRECT\"\nCVMFS_QUOTA_LIMIT=10000\n</code></pre> <p>or with bash commands:</p> <pre><code>sudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000'       &gt;&gt; /etc/cvmfs/default.local\"\n</code></pre> <p>Ensure everybody has read access to the file.</p> </li> <li> <p>Run the setup of cvmfs:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> </li> <li> <p>Now edit <code>/etc/auto.master</code> and uncomment the line     <code>#+dir:/etc/auto.master.d/</code>. E.g.,</p> <pre><code>sudo sed -i 's%#+dir:/etc/auto.master.d%+dir:/etc/auto.master.d%' /etc/auto.master\n</code></pre> </li> <li> <p>Enable and start the autofs service:</p> <pre><code>sudo systemctl enable autofs.service\nsudo systemctl start autofs\n</code></pre> <p>Or restart the autofs service if it was already present so that the above change takes effect:</p> <pre><code>sudo systemctl restart autofs\n</code></pre> </li> <li> <p>You should now be able to go into the <code>/cvmfs/software.eessi.io</code> subdirectory even if it is     not shown immediately if you do an <code>ls</code> in <code>/cvmfs</code> as it will only be mounted on access.</p> </li> <li> <p>You can now make EESSI available in a shell with</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> </li> </ul>"},{"location":"4_Cluster_Stack/4_01_EESSI/#example-setup-on-fedora-remix-in-wsl2","title":"Example: Setup on Fedora Remix in WSL2","text":"<p>Last update: 16 December 2023</p> <p>The \"Getting Started\" section of the CernVM-FS manual does contain instructions for the Fedora Linux distribution. However, there is no automatic updating of versions and one has to look for the available versions in  in the CVMFS repository @ CERN. In particular, look for the files in the newest <code>cvmfs-*</code> subdirectory and the <code>cvmfs-config</code> subdirectory.</p> <p>This setup is was tested with Fedora Remix version 39 on WSL2 with systemd enabled so that the automounter can be used and so that it is no longer needed to call <code>cvmfs_config wsl2_start</code> every time the Fedora Remix distribution in WSL is restarted.</p> <ul> <li> <p>Ensure you have a Fedora Remix WSL2 setup with systemd running. We'll enable     autofs after installing EESSI as it may not yet be on the system but would     be pulled in as a dependency of EESSI anyway.</p> <ul> <li> <p>Ensure that <code>/etc/wsl.conf</code> exists and that the <code>[boot]</code> section contains the      line <code>systemd=true</code>. The minimal <code>[boot]</code> section of this file would be</p> <pre><code>[boot]\nsystemd=true\n</code></pre> </li> <li> <p>Right now it is time to restart the Fedora Remix WSL2 distribution, e.g.,      from a normal bash command line:</p> <pre><code>/mnt/c/Windows/system32/wsl.exe --terminate $WSL_DISTRO_NAME\n</code></pre> <p>or from powershell (terminating all WSL2 distros)</p> <pre><code>wsl --shutdown\n</code></pre> </li> </ul> </li> <li> <p>Following the Fedora installation instructions,      install directly from this repository.</p> <pre><code>cvmfs_version='2.11.3'\nfedora_version='38'\nconfig_version='2.1-1'\n$SUDO dnf --assumeyes install \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-$cvmfs_version-1.fc$fedora_version.x86_64.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-config/cvmfs-config-default-$config_version.noarch.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-libs-$cvmfs_version-1.fc$fedora_version.x86_64.rpm\n</code></pre> <p>(You'll have to check the version of <code>cvmfs-config-default</code> also, there is a <code>-latest</code> version but when checking this was actually a rather old file.)</p> </li> <li> <p>Note that it is no longer needed to install the EESSI configuration file for CernVM-FS     (<code>cvmfs-config-eessi-latest.noarch.rpm</code>) as the new EESSI repository is included in     the configurations of CVMFS.</p> </li> <li> <p>Create (you'll have to run in a bash shell as root or run the editor using <code>sudo</code>) the file     <code>/etc/cvmfs/default.local</code>. If you're experimenting on a workstation with no nearby cache      server for CernVM-FS, then the following would be appropriate:</p> <pre><code>CVMFS_CLIENT_PROFILE=\"single\"\nCVMFS_HTTP_PROXY=\"DIRECT\"\nCVMFS_QUOTA_LIMIT=10000\n</code></pre> <p>or with bash commands:</p> <pre><code>sudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000'       &gt;&gt; /etc/cvmfs/default.local\"\n</code></pre> <p>Ensure everybody has read access to the file.</p> </li> <li> <p>Run the setup of cvmfs:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> </li> <li> <p>Enable and start the autofs service:</p> <pre><code>sudo systemctl enable autofs.service\nsudo systemctl start autofs\n</code></pre> <p>Or restart the autofs service if it was already present so that the above change takes effect:</p> <pre><code>sudo systemctl restart autofs\n</code></pre> </li> <li> <p>You should now be able to go into the <code>/cvmfs/software.eessi.io</code> subdirectory even if it is     not shown immediately if you do an <code>ls</code> in <code>/cvmfs</code> as it will only be mounted on access.</p> </li> <li> <p>You can now make EESSI available in a shell with</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> </li> </ul>"},{"location":"4_Cluster_Stack/4_01_EESSI/#example-setup-on-ubuntu-in-wsl2","title":"Example: Setup on Ubuntu in WSL2","text":"<p>Last update: 3 October 2024</p> <p>The \"Getting Started\" section of the CernVM-FS manual does contain instructions for the Ubuntu Linux distribution.  Contrary to Fedora and openSUSE, there is complete support for Ubuntu so the installation process is slightly different: Rather than downloading specific packages, the CERN repositories are added to the reposit list for Ubuntu and then the installation is done from there.</p> <p>This setup is was tested with Ubuntu 22.04 on WSL2 with systemd enabled so that the automounter can be used and so that it is no longer needed to call <code>cvmfs_config wsl2_start</code> every time the Ubuntu distribution in WSL is restarted.</p> <ul> <li> <p>Ensure you have a Ubuntu WSL2 setup with systemd running. We'll enable     autofs after installing EESSI as it may not yet be on the system but would     be pulled in as a dependency of EESSI anyway.</p> <ul> <li> <p>Ensure that <code>/etc/wsl.conf</code> exists and that the <code>[boot]</code> section contains the      line <code>systemd=true</code>. The minimal <code>[boot]</code> section of this file would be</p> <pre><code>[boot]\nsystemd=true\n</code></pre> </li> <li> <p>Right now it is time to restart the Ubuntu WSL2 distribution, e.g.,      from a normal bash command line:</p> <pre><code>wsl.exe --terminate $WSL_DISTRO_NAME\n</code></pre> <p>or from powershell (terminating all WSL2 distros)</p> <pre><code>wsl --shutdown\n</code></pre> </li> </ul> </li> <li> <p>Following the Debian/Ubuntu installation instructions,      first add the CERN repositories to the repository list..</p> <pre><code>pushd /tmp\nwget https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nrm -f cvmfs-release-latest_all.deb\npopd\n</code></pre> </li> <li> <p>Next we actually install CernVM-FS:</p> <pre><code>sudo apt update\nsudo apt --assume-yes install cvmfs\n</code></pre> </li> <li> <p>Note that it is no longer needed to install the EESSI configuration file for CernVM-FS     (<code>cvmfs-config-eessi-latest.noarch.rpm</code>) as the new EESSI repository is included in     the configurations of CVMFS.</p> </li> <li> <p>Create (you'll have to run in a bash shell as root or run the editor using <code>sudo</code>) the file     <code>/etc/cvmfs/default.local</code>. If you're experimenting on a workstation with no nearby cache      server for CernVM-FS, then the following would be appropriate:</p> <pre><code>CVMFS_CLIENT_PROFILE=\"single\"\nCVMFS_HTTP_PROXY=\"DIRECT\"\nCVMFS_QUOTA_LIMIT=10000\n</code></pre> <p>or with bash commands:</p> <pre><code>sudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000'       &gt;&gt; /etc/cvmfs/default.local\"\n</code></pre> <p>Ensure everybody has read access to the file.</p> </li> <li> <p>Run the setup of cvmfs:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> </li> <li> <p>Enable and start the autofs service:</p> <pre><code>sudo systemctl enable autofs.service\nsudo systemctl start autofs\n</code></pre> <p>Or restart the autofs service if it was already present so that the above change takes effect:</p> <pre><code>sudo systemctl restart autofs\n</code></pre> </li> <li> <p>You should now be able to go into the <code>/cvmfs/software.eessi.io</code> subdirectory even if it is     not shown immediately if you do an <code>ls</code> in <code>/cvmfs</code> as it will only be mounted on access.</p> </li> <li> <p>You can now make EESSI available in a shell with</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> </li> </ul>"},{"location":"4_Cluster_Stack/4_01_EESSI/#useful-links","title":"Useful links","text":"<ul> <li> <p>EESSI web page</p> </li> <li> <p>EESSI documentation</p> </li> <li> <p>EESSI YouTube channel</p> </li> <li> <p>MultiXscale Center of Excellence:</p> <ul> <li> <p>Home page</p> </li> <li> <p>YouTube channel</p> </li> </ul> </li> </ul>"},{"location":"4_Cluster_Stack/4_02_EasyBuild/","title":"EasyBuild software installation","text":""},{"location":"4_Cluster_Stack/4_03_Spack/","title":"Spack package manager","text":""},{"location":"5_Issues/","title":"Issues","text":"<ul> <li>SSH key management</li> <li>Connecting to an X server in the Windows process space</li> <li>Securing an X server in the Windows process space</li> <li>Mapping users and groups between the Windows and WSL space</li> <li>Upgrading Linux in WSL</li> </ul>"},{"location":"5_Issues/5_01_SSH_key_management/","title":"SSH key management","text":""},{"location":"5_Issues/5_01_SSH_key_management/#using-the-windows-ssh-agent","title":"Using the Windows SSH agent","text":"<p>Windows does come with a ssh key agent service. However, in recent versions of Windows 10, it is disabled by default. To enable it,</p> <ol> <li> <p>Open the \"Services\" app in administrator mode</p> </li> <li> <p>Look for \"OpenSSH Authentication Agent\" in the list of services and     right-click to open the \"Properties\" dialog box.</p> </li> <li> <p>Make sure the startup-type is set to \"automatic\" which will ensure     that the service will start the next time Windows is booted.</p> </li> <li> <p>It should also be possible to start the service now from the same     dialog box.</p> </li> </ol> <p>Keys can then be added from PowerShell using the regular \"ssh-add\"-command.</p> <p>There is a caveat however. The ssh agent service is not found from WSL. Solutions:</p> <ul> <li> <p>WSL 1: A piece of software called     \"wsl-ssh-agent\" can     be used to connect WSL 1 sessions to the ssh agent service in     Windows.</p> </li> <li> <p>WSL 2: Here a different approach has to be taken, using <code>socat</code> (which     you may need to install in your Linux distribution) and a Windows     program, npiperelay.exe,     that needs to be installed on a Windows file system (as Windows must     be able to run the program).     This should be set up in your .bash_profile or .bashrc (I do so in     .bash_profile as that is the typical place to set environment     variables):</p> <pre><code>export SSH_AUTH_SOCK=/home/$USER/.agent.sock.$WSL_DISTRO_NAME\nss -a | grep -q $SSH_AUTH_SOCK\nif [ $? -ne 0   ]; then\n    rm -f $SSH_AUTH_SOCK\n    ( setsid socat UNIX-LISTEN:$SSH_AUTH_SOCK,fork,umask=077 EXEC:\"$HOME/.wsl/npiperelay.exe -ei -s //./pipe/openssh-ssh-agent\",nofork &amp; ) &gt;/dev/null 2&gt;&amp;1\nfi\n</code></pre> <p>(The <code>umask=077</code> part in the line above can in most cases be omitted as  the UNIX domain socket is created in the home diretory and hence shouldn't be accessible to others anyway.)</p> </li> </ul> <p>There are a few caveats:</p> <ul> <li> <p><code>SSH_AUTH_SOCK</code> points to the socket that will be used to communicate     with the ssh agent. In most (all?) WSL distributions, this should be on an     internal Linux file system. So in case you use your Windows home     directory also as the home directory in your WSL distribution, you     should not put the socket there. This is why <code>/home/$USER</code> is used     rather than <code>$HOME</code>. Also, if you have multiple Linux distributions     in WSL, it is important that the socket has a different name for     each distribution as otherwise one distribution will try to talk to     a socket in a different distribution. At first this may seem     possible since all distributions run in the same virtual machine,     but they have different user spaces so that does not work.</p> </li> <li> <p>The second line tests if there is already an <code>socat</code> process managing     that socket.</p> </li> <li> <p>The crucial line is the <code>setsid socat</code> line:</p> <ul> <li> <p>The Windows ssh agent works with Windows named pipes, and WSL2     programs cannot directly talk to those. This is where     <code>npiperelay.exe</code> comes in. It acts as the translator between Linux     sockets and the Windows named pipe.</p> </li> <li> <p>The <code>socat</code> process listens at the Linux side. Whenever ssh     contacts the socket, it starts <code>npiperelay.exe</code> to talk to the     Windows named pipe. The <code>npiperelay.exe</code> process is started with     options that will terminate it after the command from the ssh     process.</p> </li> <li> <p>The path specified for the <code>npiperelay.exe</code> command is the path as     seen by the Linux distribution.</p> </li> <li> <p>The <code>setsid</code> command is used to start it in a separate session so     that it continues running if the current Linux session is     terminated, to be picked up again when you start a new shell in     that distribution.</p> </li> </ul> </li> </ul> <p>At the moment of writing, this process was tested and works in Fedora 38, OpenSUSE 15 SP4 and Ubuntu 22.4.2 LTS.  It does require updating the ssh-agent in Windows though is easy to do  with a beta version  as MSI packages are available. I did find a download site with release versions also but lost the link and it only contained compressed archives containing a PowerShell script to install that needed to be run in a special way to work properly.</p> <p>Some good sources of information on this procedure:</p> <ul> <li> <p>The wsl-ssh-agent     github mentions it     as the alternative for WSL2.</p> </li> <li> <p>\"Forwarding SSH agent requests from WSL to Windows\" on     stuartleeks.com     is a slightly more complicated version of this procedure that     prevents accidentally starting more socat processes than needed.</p> </li> <li> <p>\"Using SSH on Windows 10 and WSL 2\" on     markramige.com     is a page that explains the whole process of setting up the Windows     OpenSSH implementation and integrating it with WSL.</p> </li> </ul>"},{"location":"5_Issues/5_01_SSH_key_management/#key-permissions-related-problems","title":"Key permissions-related problems","text":"<p>Ubuntu 20.4 and 22.4 have problems using key files symlinked on a regular Windows file system. It shows when an IdentityFile line with IdentitiesOnly is added to the <code>.ssh/config</code> file for the host and the key that is used there is a symbolic link to the actual key. And this in turn seems to be related to a permissions problem in WSL2 when using a Windows file system: It is not possible to set the permissions on the links themselves to 700 while that seems to be needed for the Ubuntu ssh client (according to a web search on possible causes). In general, the mapping between users and groups on the WSL2 side and on the Windows side seems to differ between distributions and can be the cause of problems.</p>"},{"location":"5_Issues/5_02_Connecting_WinX/","title":"Connecting to an X server in the Windows process space","text":"<p>This section is irrelevant if you are using the X server in the WSL subsystem in Windows 10 21H2 or later or Windows 11.</p> <p>TODO</p>"},{"location":"5_Issues/5_03_SecureX/","title":"Securing an X server in the Windows process space","text":"<p>The best way of course if you only want access to the X server from programs running on your PC, is to limit access to the X server via firewall software. How this should be done depends on the firewall that you are using. One problem is that if you are using WSL2, you need to ensure access from the virtual interface of the WSL2 virtual machine, which is in the 172.16.0.0/12 range (or maybe even always in the 172.31.0.0/16 range).</p> <p>An easy way to limit the access is via the <code>xhost</code> command, which you would need to install in your Linux distribution. On the machine on which we tested we found the following to work from CygWin and three different Linux distributions (Fedora, openSUSE and Ubuntu):</p> <pre><code>xhost +$HOSTNAME.mshome.net +localhost -\n</code></pre> <p>The \"<code>+$HOSTNAME.mshome.net</code>\" grants access to the virtual interface of the WSL2 virtual machine (and is not needed on WSL1), the \"+localhost\" grants access to local X11 programs (important for CygWin and WSL1) and the \"-\" denies access to everyone else.</p>"},{"location":"5_Issues/5_04_Mapping_users/","title":"Mapping users and groups between the Windows and WSL space","text":"<p>Users and groups seem to be mapped differently on WSL users and groups depending on the distribution and this may cause problems for accesses to files that are sensitive to permissions, e.g., access to ssh keys.</p> <p>TODO</p>"},{"location":"5_Issues/5_05_Upgrading_Linux/","title":"Upgrading Linux in WSL","text":""},{"location":"5_Issues/5_05_Upgrading_Linux/#ubuntu","title":"Ubuntu","text":"<ul> <li> <p>It is best to first make sure that your current Ubuntu is up-to-date:</p> <pre><code>sudo apt update\nsudo apt full-upgrade\n</code></pre> <p>You can optionally add the <code>-y</code> command line flag to the last command to automatically assume the answer \"yes\" to all questions asked during the process.</p> <p>The <code>apt update</code> command downloads package information from all configured sources that is  used by other <code>apt</code> commands. The <code>apt full-upgrade</code> command install available upgrades of  all packages currently installed on the system, installs new ones as required but also removes currently installed packages if this is needed to upgrade the system as a whole.</p> </li> <li> <p>It may be a good moment for some clean-up:</p> <pre><code>sudo apt --purge autoremove\n</code></pre> <p>This command will remove packages that were automatically installed to satisfy dependencies for other packages and are now no longer needed as dependencies changed or the package(s) needing them were removed in the meantime.</p> <p>It may remove more than you like though as some software that came in as a dependency of explicitly installed packages may still be used by itself. See the  manual pages of the <code>apt</code> command on how to deal with this.</p> </li> <li> <p>The actual release policy is set in <code>/etc/update-manager/release-upgrades</code>.     Edit this file (using an editor via the <code>sudo</code> command) to change the policy     if desired. If Ubuntu was installed via the Windows store, this should be set     to only installing LTS versions, but you can change this at your own risk.</p> </li> <li> <p>To initiate the actual upgrade, run</p> <pre><code>sudo do-release-upgrade -d\n</code></pre> <p>The <code>-d</code> option (which tells to use the latest development release)  turned out to be essential though many sources don't mention it. Without it the <code>do-release-upgrade</code> command failed to recognise that there was a new version of Ubuntu available when I tested the procedure. It might be because I tested too  early. The new release of Ubuntu was already available in the Windows store but  it might not have been marked yet for general distribution via the upgrade mechanism. (See also the <code>do-release-upgrade</code> manual page)</p> <p>You will be asked a few questions during the process about how to proceed.  <code>y</code> is most of the time a suitable answer.</p> <p>Note that on WSL2 (and I guess WSL also) you will see an error message when  Ubuntu tries to restart at the end of the process as the Linux infrastructure that is used for that is not supported on WSL/WSL2. You'll have to leave all Ubuntu sessions and it may even be a good idea to simply restart Windows.</p> </li> </ul>"},{"location":"A_Management_tips/","title":"Appendix A: Management tips","text":"<ul> <li>openSUSE on WSL2</li> <li>Fedora Remix</li> <li>Ubuntu</li> </ul>"},{"location":"A_Management_tips/A_01_openSUSE/","title":"Some openSUSE management tips","text":"<p>These tips are based on my personal setup. I hope the example may be inspiring.</p> <p>Basically I use openSUSE in WSL2 and have enabled systemd so that the automounter can be used, which makes it easier to also use EESSI. I use the same userid in WSL2 as in Windows and have changed my home directory to my Windows user directory. This does come with a performance penalty. However, the personal directory that is created in <code>/home</code> still  exists and is used for some files that are different between distributions anyway (and for setting up a connection to the Windows ssh agent). I do store most files that cannot be easily regenerated in the Windows user diretories though as that makes experimenting with WSL, which may destroy my setup, easier.</p> <p>I've also set up the distribution to use WSLg so that GUI software can also run.</p> <p>Using systemd and WSLg also implies that you need at least a recent version of Windows 10 or higher, with the Microsoft Store version of WSL2.</p> <p>Installation instructions for WSL are available on the Microsoft web pages.</p>"},{"location":"A_Management_tips/A_01_openSUSE/#installation-scripts","title":"Installation scripts","text":"<p>I have had to re-install my openSUSE distribution a few times already, also because I  experiment a lot (also to write this documentation) or want to execute the instructions again to make sure that no steps are forgotten in these notes. Hence I collect much of the work in scripts to speed up rebuilding.</p> <p>The instructions are also inspired by the openSUSE:WSL page in the opensuse.org wiki, CernVM-FS (cvmfs) documentation and EESSI documentation.</p> <p>Basically I took the following steps when installing openSUSE:</p> <ul> <li> <p>In the setup program, I create a userid that is the same as my Windows userid,     and I also use the same password to avoid confusion. </p> <p>The option : Use this password for system administrator\" is also left checked.</p> </li> <li> <p>I run an install script that execute a lot of commands via <code>sudo</code>. At the end a restart     is needed to ensure that changes take effect and a new session with systemd running     is started. After the reboot the automounter should be working so that you get      direct access to, e.g., EESSI.</p> <pre><code>#! /usr/bin/bash\n\n# Make the next one an empty variable if instead you prefer to run\n# the whole script in sudo mode. You then however also need to\n# change set the userid that should be edited in edituser\nSUDO='sudo'\nedituser=\"$USER\"\n\n# Upgrade the already installed packages\n$SUDO zypper -n update\n\n# Some patterns that should be installed or are interesting to install\n# according to https://en.opensuse.org/openSUSE%3AWSL\n# These scripts try to make their own wsl.conf but as a symbolic link\n# to one they include and they don't play nice with each other.\n# Which is why we will regenerate our own in the next step.\n$SUDO zypper -n install -t pattern wsl_systemd\n$SUDO /bin/rm /etc/wsl.conf\n$SUDO zypper -n install -t pattern wsl_base\n$SUDO /bin/rm /etc/wsl.conf\n$SUDO zypper -n install -t pattern wsl_gui\n$SUDO /bin/rm /etc/wsl.conf\n\n# Enable systemd (will only work after a reboot)\n$SUDO bash -c \"echo -e '[boot]\\nsystemd=true' &gt;/etc/wsl.conf\"\n\n# Set the home directory of my account to the one on Windows\n$SUDO sed -i -e \"s|/home/$edituser|/mnt/c/Users/$edituser|\" /etc/passwd\n\n#\n# Setting up EESSI\n#\n# This also ensure that the autofs service will be present\n#\ncvmfs_version='2.11.2'\nconfig_version='2.1-1'\n$SUDO zypper --no-gpg-checks --non-interactive install \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-config/cvmfs-config-default-$config_version.noarch.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-$cvmfs_version-1.sle15.x86_64.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-libs-$cvmfs_version-1.sle15.x86_64.rpm\n\n# Create /etc/cvmfs/default.local\n$SUDO bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_QUOTA_LIMIT=2500'        &gt;&gt; /etc/cvmfs/default.local\"\n\n# Run the setup\n$SUDO cvmfs_config setup\n\n# Not sure if the next one is already needed on OpenSUSE on WSL2:\n# Uncomment the line #+dir:/etc/auto.master.d/ in the file /etc/auto.master\n$SUDO sed -i 's%#+dir:/etc/auto.master.d%+dir:/etc/auto.master.d%' /etc/auto.master\n\n# Already create /opt/eessi for EESSI even though we do not yet use it\n$SUDO mkdir -p /opt/eessi\n\n# Enable autofs.service so that it is started after the next \n# reboot.\n$SUDO systemctl enable autofs.service\n\n#\n# End of EESSI setup\n#\n\n#\n# Install a number of useful packages\n#\n\n# socat to get access to the SSH agent of Windows\n$SUDO zypper --non-interactive install socat\n\n# Git\n$SUDO zypper --non-interactive install git\n\n# VIM colorschemes\n$SUDO zypper --non-interactive install vim-plugin-colorschemes\n\n# Newer Python. For OpenSUSE 15 SP4 this is Python 3.9 or Python 3.11\n$SUDO zypper --non-interactive install python311\n\n# Something to test if the X server is recognised\n$SUDO zypper --non-interactive install xdpyinfo\n\n# Give a message about the needed restart\necho -e \"Now reboot WSL2 or at least this distribution to enable systemd, e.g.,\" \\\n        \"\\nwsl.exe --shutdown\" \\\n        \"\\nor more selectively\" \\\n        \"\\nwsl.exe --terminate $WSL_DISTRO_NAME\"\n</code></pre> <p>There are ways to enable systemd globally for all distributions but that option turned out to be rather dangerous as some distributions, including openSUSE Leap 15.4 which I used for the tests for this section, do not have the necessary setup right away to use systemd, leading to hanging distros.</p> </li> </ul> SUSE patterns <p>The patterns are supposed to install necessary software for some additional functionality and set up links, configuration files, etc. </p> <p>Some information about the WSL patterns used in the above scripts:</p> <ul> <li> <p>On build.opensuse.org</p> </li> <li> <p>In a GitHub repository</p> </li> </ul> <p>It looks like the <code>wsl_systemd</code> pattern tries to remove a command from the commands that automatically execute at startup, but it doesn't do so in a robust way as it would be added again if one of the other patterns is installed later, and as there are some troubles with <code>wsl.conf</code> being linked to the actual file rather than a copy, which is why we chose to create <code>/etc/wsl.conf</code> by hand.</p>"},{"location":"A_Management_tips/A_02_Fedora_Remix/","title":"Fedora Remix","text":"<p>These tips are based on my personal setup. I hope the example may be inspiring.</p> <p>Fedora Remix is a Fedora distribution offered through the Microsoft Store by Whitewater Foundry, a company specialising in Linux distributions for WSL.</p> <p>The setup I have for Fedora is similar to the setup I use for openSUSE.  I enabled systemd at all time so that the automounter can be used, which makes it easier to also use EESSI. I use the same userid in WSL2 as in Windows and have changed my home directory to my Windows user directory. This does come with a performance penalty. However, the personal directory that is created in <code>/home</code> still  exists and is used for some files that are different between distributions anyway (and for setting up a connection to the Windows ssh agent). I do store most files that cannot be easily regenerated in the Windows user diretories though as that makes experimenting with WSL, which may destroy my setup, easier.</p> <p>WSLg is also supported. Note that the use of systemd (and WSLg) requires a recent version of Windows 10 or higher with the Microsoft Store version of WSL2.</p> <p>Installation instructions for WSL are available on the Microsoft web pages.</p>"},{"location":"A_Management_tips/A_02_Fedora_Remix/#installation-scripts","title":"Installation scripts","text":"<p>I have had to re-install my Fedora distribution a few times already, also because I  experiment a lot (also to write this documentation) or want to execute the instructions again to make sure that no steps are forgotten in these notes. Hence I collect much of the work in scripts to speed up rebuilding.</p> <p>The instructions are also inspired by the CernVM-FS (cvmfs) documentation and EESSI documentation.</p> <p>Basically I took the following steps when installing Fedora Remix:</p> <ul> <li> <p>In the setup program that is run when Fedora is started for the first time,      I create a userid that is the same as my Windows userid,     and I also use the same password to avoid confusion. </p> </li> <li> <p>I run an install script that execute a lot of commands via <code>sudo</code>. At the end a restart     is needed to ensure that changes take effect and a new session with systemd running     is started. After the reboot the automounter should be working so that you get      direct access to, e.g., EESSI.</p> <p><pre><code>#! /usr/bin/bash\n\n# Make the next one an empty variable if instead you prefer to run\n# the whole script in sudo mode. You then however also need to\n# change set the userid that should be edited in edituser\nSUDO='sudo'\nedituser=\"$USER\"\n\n# Upgrade the already installed packages\n$SUDO dnf --assumeyes update\n\n# Ensure systemd is always used, independent of the options chosen\n# when starting the first Fedora Remix session.\n# If you are running without systemd, you'll have to restart which\n# is done at the end of the script.\n$SUDO bash -c \"echo -e '\\n[boot]\\nsystemd=true' &gt;&gt;/etc/wsl.conf\"\n\n# Set the home directory of my account to the one on Windows\n$SUDO sed -i -e \"s|/home/$edituser|/mnt/c/Users/$edituser|\" /etc/passwd\n\n#\n# Setting up EESSI\n#\n# Note that this will actually pull in the autofs service as a dependency\n#\ncvmfs_version='2.11.2'\nfedora_version='38'\nconfig_version='2.1-1'\n$SUDO dnf --assumeyes install \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-$cvmfs_version-1.fc$fedora_version.x86_64.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-config/cvmfs-config-default-$config_version.noarch.rpm \\\n    https://ecsft.cern.ch/dist/cvmfs/cvmfs-$cvmfs_version/cvmfs-libs-$cvmfs_version-1.fc$fedora_version.x86_64.rpm\n\n# Create /etc/cvmfs/default.local\n$SUDO bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_QUOTA_LIMIT=2500'        &gt;&gt; /etc/cvmfs/default.local\"\n\n# Run the setup\n$SUDO cvmfs_config setup\n\n# Already create /opt/eessi for EESSI even though we do not yet use it\n$SUDO mkdir -p /opt/eessi\n\n# Enable autofs.service so that it is started after the next \n# reboot.\n$SUDO systemctl enable autofs.service\n\n#\n# End of EESSI setup\n#\n\n#\n# Install some other useful tools\n#\n\n# socat to get access to the SSH agent of Windows\n$SUDO dnf --assumeyes install socat\n\n# Git\n$SUDO dnf --assumeyes install git\n\n# Need Python 3.11 as not all packages already support 3.12.\n$SUDO dnf --assumeyes install python3.11\n\n# Something to test if the X server is recognised\n$SUDO dnf --assumeyes install xdpyinfo\n\n# Give a message about the needed restart to ensure all settings take\n# effect.\necho -e \"Now reboot WSL2 or at least this distribution to enable systemd, e.g.,\" \\\n        \"\\nwsl.exe --shutdown\" \\\n        \"\\nor more selectively and from the Fedora shell\" \\\n        \"\\n/mnt/c/Windows/system32/wsl.exe --terminate $WSL_DISTRO_NAME\"\n</code></pre> There are ways to enable systemd globally for all distributions but that option turned out to be rather dangerous as some distributions, including openSUSE Leap 15.4 which I used for the tests for this section, do not have the necessary setup right away to use systemd, leading to hanging distros.</p> </li> </ul> <p>The default <code>/etc/wsl.conf</code> file suggests there might be a way to get the automounter working without systemd, but I haven't found out how yet. That would also enable  CernVM-FS to work without having to run <code>cvmfs_config wsl2_start</code> each time Fedora Remix is restarted.</p>"},{"location":"A_Management_tips/A_03_Ubuntu/","title":"Ubuntu","text":"<p>These tips are based on my personal setup. I hope the example may be inspiring.</p> <p>Ubuntu is the default Linux distribution for WSL2 and certainly the one recommended by Microsoft. Support in CernVM-FS is certainly better than for openSUSE or Fedora, and should include automatic updating. In general though more commands are needed to set up an Ubuntu system than a Fedora or openSUSE system on WSL2 and I also experience more problems to get, e.g., access to the Windows ssh agent working.</p> <p>The setup I have for Ubuntu is similar to the setup I use for openSUSE and Fedora.  I enabled systemd at all time so that the automounter can be used, which makes it easier to also use EESSI. I use the same userid in WSL2 as in Windows and have changed my home directory to my Windows user directory. This does come with a performance penalty. However, the personal directory that is created in <code>/home</code> still  exists and is used for some files that are different between distributions anyway (and for setting up a connection to the Windows ssh agent). I do store most files that cannot be easily regenerated in the Windows user diretories though, as that makes experimenting with WSL, which may destroy my setup, easier.</p> <p>WSLg is also supported. Note that the use of systemd (and WSLg) requires a recent version of Windows 10 or higher with the Microsoft Store version of WSL2.</p> <p>Installation instructions for WSL are available on the Microsoft web pages.</p>"},{"location":"A_Management_tips/A_03_Ubuntu/#installation-scripts","title":"Installation scripts","text":"<p>I have had to re-install my Ubuntu distribution a few times already, also because I  experiment a lot (also to write this documentation) or want to execute the instructions again to make sure that no steps are forgotten in these notes. Hence I collect much of the work in scripts to speed up rebuilding.</p> <p>The instructions are also inspired by the CernVM-FS (cvmfs) documentation and EESSI documentation.</p> <p>Basically I took the following steps when installing Ubuntu:</p> <ul> <li> <p>In the setup program that is run when Ubuntu is started for the first time,      I create a userid that is the same as my Windows userid,     and I also use the same password to avoid confusion. </p> </li> <li> <p>I run an install script that execute a lot of commands via <code>sudo</code>. At the end a restart     is needed to ensure that changes take effect and a new session with systemd running     is started. After the reboot the automounter should be working so that you get      direct access to, e.g., EESSI.</p> <pre><code>#! /usr/bin/bash\n\n# Make the next one an empty variable if instead you prefer to run\n# the whole script in sudo mode. You then however also need to\n# change set the userid that should be edited in edituser\nSUDO='sudo'\nedituser=\"$USER\"\n\n# Update the package list and then do a full upgrade of the default packages\n$SUDO apt update\n$SUDO apt --assume-yes full-upgrade\n\n# Ensure systemd is always used, independent of the options chosen\n# when starting the first Ubuntu session.\n# If you are running without systemd, you'll have to restart which\n# is done at the end of the script.\n$SUDO bash -c \"echo -e '\\n[boot]\\nsystemd=true' &gt;&gt;/etc/wsl.conf\"\n\n# Set the home directory of my account to the one on Windows\n$SUDO sed -i -e \"s|/home/$edituser|/mnt/c/Users/$edituser|\" /etc/passwd\n\n#\n# Setting up EESSI\n#\n# Note that this will actually pull in the autofs service as a dependency\n#\n\n#\n# Install cfmfs-release-latest_all.deb\n# This will add some cern repos to the list that ap will search.\n#\npushd /tmp\nwget https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\n$SUDO dpkg -i cvmfs-release-latest_all.deb\nrm -f cvmfs-release-latest_all.deb\npopd\n\n#\n# Now install cvmfs\n# But don't forget to first pull in data from the repos that we have\n# added in the previous step.\n#\n$SUDO apt update\n$SUDO apt --assume-yes install cvmfs\n# Note: I did get an error while processing openssh-server.\n# This doesn't seem to be needed though.\n\n# Create /etc/cvmfs/default.local\n$SUDO bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"'  &gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_HTTP_PROXY=\"DIRECT\"'     &gt;&gt; /etc/cvmfs/default.local\"\n$SUDO bash -c \"echo 'CVMFS_QUOTA_LIMIT=2500'        &gt;&gt; /etc/cvmfs/default.local\"\n\n# Run the setup\n$SUDO cvmfs_config setup\n\n# Already create /opt/eessi for EESSI even though we do not yet use it\n$SUDO mkdir -p /opt/eessi\n\n# Enable autofs.service so that it is started after the next \n# reboot.\n$SUDO systemctl enable autofs.service\n\n#\n# End of EESSI setup\n#\n\n#\n# I don't want an ssh server running for now\n#\n$SUDO systemctl disable ssh.service\n\n#\n# Install some other useful tools\n#\n\n# socat to get access to the SSH agent of Windows\n$SUDO apt --assume-yes install socat\n\n# Git\n$SUDO apt --assume-yes install git\n\n# Need Python 3.11 (the distribution I tested on took 3.8 as the default).\n# Wee needed to install it from \"deadsnakes PPA\"\n$SUDO apt --assume-yes install software-properties-common -y\n$SUDO add-apt-repository --yes --update ppa:deadsnakes/ppa\n$SUDO apt --assume-yes install python3.11\n\n# Tools for building software\n$SUDO apt --assume-yes install make\n\n# Some cleanup\n$SUDO apt --assume-yes autoremove\n\n# Give a message about the needed restart to ensure all settings take\n# effect.\necho -e \"Now reboot WSL2 or at least this distribution to enable systemd, e.g.,\" \\\n        \"\\nwsl.exe --shutdown\" \\\n        \"\\nor more selectively and from the Ubuntu shell\" \\\n        \"\\nwsl.exe --terminate $WSL_DISTRO_NAME\"\n</code></pre> <p>There are ways to enable systemd globally for all distributions but that option turned out to be rather dangerous as some distributions, including openSUSE Leap 15.4 which I used for the tests for this section, do not have the necessary setup right away to use systemd, leading to hanging distros.</p> </li> </ul>"}]}